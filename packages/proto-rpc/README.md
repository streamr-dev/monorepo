proto-rpc
===========

Transport-independent [protobuf](https://developers.google.com/protocol-buffers) RPC for Node.js and the Web Browser. 
Binary alternative to JSON-RPC. Uses [protobuf-ts](https://github.com/timostamm/protobuf-ts) for code generation. Pure TypeScript.

## Introduction

proto-rpc is intended for situations where you would normally use JSON-RPC, but would like to switch to a binary protocol with autogenerated, typesafe code.  

Unlike existing RPC frameworks such as gRPC, gRPC-web and twirp, proto-rpc is totally transport-independent; it simply produces `Uint8Arrays` and transporting them to the recipient is totally up to you! You can use Websockets, peer-to-peer networks, WebRTC, UDP, TCP, just to name a few.

## Usage

- `npm install @streamr/proto-rpc`
  > installs the library

- write RPC service description in a `.proto` file:

```proto
syntax = "proto3";

service HelloRpc {
  rpc sayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
    string myName = 1;
  }
  
message HelloResponse {
    string greeting = 1;
  }
```
  > `HelloRpc.proto`

- generate client and server classes using protobuf-ts:

```bash
mkdir -p ./proto
npx protoc --ts_out $(pwd)/proto --ts_opt server_generic,generate_dependencies --proto_path $(pwd) HelloRpc.proto
```

- implement the auto-generated IHelloRpc server interface in TypeScript

```typescript
class HelloService implements IHelloRpc {
    async sayHello(request: HelloRequest, _context: ServerCallContext): Promise<HelloResponse> {
        return { greeting: 'Hello ' + request.myName + '!' }
    }
}
```

- start a RpcCommunicator for the server side, and register the RPC method you just created.
  *Note that a RpcCommunicator can act both as a client and a server at the same time*    

```typescript
    const communicator1 = new RpcCommunicator()
    const helloService = new HelloService()
    communicator1.registerRpcMethod(HelloRequest, HelloResponse, 'sayHello', helloService.sayHello)
```

- start a RPC communicator for the client side, register the RPC method you just created,
  and bind it to the auto-generated HelloClient class


```typescript
    const communicator2 = new RpcCommunicator()
    const helloClient = new HelloRpcClient(communicator2.getRpcClientTransport())
```

- listen to outgoing packets from the RpcCpommunicators on both the client and server sides, and
  deliver them to the correct recipient. In real life this would happen over a network connection (Websocket, WebRTC, HTTP..)
  but here we will simulate the connection using method calls.

```typescript
    communicator1.on(RpcCommunicatorEvents.OUTGOING_MESSAGE, 
      (msgBody: Uint8Array, _ucallContext?: CallContext) => {
        communicator2.handleIncomingMessage(msgBody)
    })
    communicator2.on(RpcCommunicatorEvents.OUTGOING_MESSAGE, 
      (msgBody: Uint8Array, _ucallContext?: CallContext) => {
        communicator1.handleIncomingMessage(msgBody)
    })
```

- make the RPC call and print the result
  
```typescript
    const result = await helloClient.sayHello({ myName: 'Alice' })
    console.log(result.response.greeting)
```

- finally, discard the RpcCommunicators to clean up pontially pending async calls and other
  allocated resources
  
```typescript
    communicator1.stop()
    communicator2.stop()
```

For complete code example, see [examples/hello](examples/hello)

## Advanced topics

### Passing context information (eg. for routing)

You can pass context information through the RpcCommunicator between the clients, RPC methods and the event handlers. This is
especially useful in case you wish to use a single RpcCommunicator as a server for multiple clients, and need to figure out
where to route the Uint8Arrays output by the RpcCommunicator. 

### Notifications

### Errors and timeouts
